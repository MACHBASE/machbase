---
title: MAP Functions
type: docs
weight: 31
---

*MAP* functions are the core of the transforming data.


## TAKE()

![map_take](../img/map_take.jpg)

*Syntax*: `TAKE( [offset,] n )`

Takes first *n* records and stop the stream.

- `offset` *number* optional, take records from the offset. (default 0 when omitted) {{< neo_since ver="8.0.6" />}}
- `n` *number* specify how may records to be taken.

## DROP()

![map_drop](../img/map_drop.jpg)

*Syntax*: `DROP( [offset,] n  )`

Ignore first *n* records, it simply drops the *n* records.

- `offset` *number* optional, drop records from the offset. (default 0 when omitted) {{< neo_since ver="8.0.6" />}}
- `n` *number* specify how may records to be dropped.

## MAPKEY()

![map_mapkey](../img/map_mapkey.jpg)

*Syntax*: `MAPKEY( newkey )`

Replace current key value with the given newkey.

## PUSHKEY()

![map_pushkey](../img/map_pushkey.jpg)

*Syntax*: `PUSHKEY( newkey )`

Apply new key on each record. The orignal key is push into value tuple.

For example, if an original record was `{key: 'k1', value: [v1, v2]}` and applied `PUSHKEY(newkey)`, it produces the updated record as `{key: newkey, values: [k1, v1, v1]}`.

## POPKEY()

![map_popkey](../img/map_popkey.jpg)

*Syntax*: `POPKEY( [idx] )`

Drop current key of the record, then promote *idx*th element of *tuple* as a new key.

For example, if an original record was `{key: k, value: [v1, v2, v3]}` and applied `POPKEY(1)`, it produces the updated record as `{key: v2, value:[v1, v3]}`.

if use `POPKEY()` without argument it is equivalent with `POPKEY(0)` which is promoting the first element of the value tuple as the key.

## GROUPBYKEY()

![map_popkey](../img/map_groupbykey.jpg)

*Syntax*: `GROUPBYKEY( [lazy(boolean)] )`

- `lazy(boolean)` If it set `false` which is default *GROUPBYKEY()* yields new grouped record when the key of incoming record has changed from previous record. If it set `true`, *GROUPBYKEY()* waits the end of the input stream before yield any record. 

Takes multiple continuous records that have same key, then produces a new record which have value array contains all individual values.

For example, if an original records was `{key:k, value:[v1, v2]}`, `{key:k, value:{v3, v4}}`...`{key:k, value:{vx, vy}}`, it produces the new record as `{key:k, value:[[v1,v2],[v3,v4],...,[vx,vy]]}`.

The *GROUPBYKEY()* works comparing the key of current record to previous one, if it found the key has been changed, then produces new record. As result it can makes a group only if the continuous records have same key.

## FLATTEN()

![map_flatten](../img/map_flatten.jpg)

*Syntax*: `FLATTEN()`

It works the oposite way of *GROUPBYKEY()*. Take a record whose value is multi-dimension tuple, produces multiple records for each elements of the tuple reducing the dimension.

For example, if an original record was `{key:k, value:[[v1,v2],[v3,v4],...,[vx,vy]]}`, it produces the new multiple records as `{key:k, value:[v1, v2]}`, `{key:k, value:{v3, v4}}`...`{key:k, value:{vx, vy}}`.

## PUSHVALUE()

*Syntax*: `PUSHVALUE( idx, value [, name] )` {{< neo_since ver="8.0.5" />}}

- `idx` *int* Index where newValue insert at. (0 based)
- `value` *expression* New value
- `name` *string* column's name (default 'column')

Insert the given value into the current values.

## POPVALUE()

*Syntax*: `PUSHVALUE( idx [, idx2, idx3, ...] )` {{< neo_since ver="8.0.5" />}}

- `idx` *int* array of indexes that will removed from values

It removes elements that specified by `idx`es from value array.

## MAPVALUE()

![map_mapvalue](../img/map_mapvalue.jpg)

*Syntax*: `MAPVALUE( idx, newValue [, newName] )`

- `idx` *int*  Index of the value tuple. (0 based)
- `newValue` *expression* New value
- `newName` *string* change column's name with given string

Replace the value of the element at the given index. For examaple, `MAPVALUE(0, value(0)*10)` replaces a new value that is 10 times of the first element of value tuple.

If the `idx` is out of range, it will work as `PUSHVALUE()` does. `MAPVALUE(-1, value(1)+'_suffix')` inserts a new string value that concatenates '_suffix' with the 2nd element of value.

## FILTER()

![map_filter](../img/map_filter.jpg)

*Syntax*: `FILTER( condition )`

Apply the condition statement on the incoming record, then it pass the record only if the *condition* is *true*.

For example, if an original record was `{key: k1, value[v1, v2]}` and apply `FILTER(count(V) > 2)`, it simply drop the record. If the codition was `FILTER(count(V) >= 2)`, it pass the record to the next function.

## TIMEWINDOW()

*Synatax*: `TIMEWINDOW( fromTime, untilTime, period, [nullValue], fields...)` {{< neo_since ver="8.0.5" />}}

Aggregate raw values between fromTime and untilTime into a periodic duration and fill zero value if any value exists for the period.

- `fromTime` *time* from (inclusive)
- `untilTime` *time* until (exclusive)
- `period` *duration* ex: `period('1s')`
- `nullValue` if a certain period has no actual values it yields the given *alternativeValue*.(default is *NULL*) ex: `nullValue(alternativeValue)`
- `fields` *string* specifies each field's aggration function and indicates which column is the time. It should be one of pre-defines keywords. 

| field          |  description         |
| :------------- | :------------------- |
| `time`         | indicator for timestamp column  |
| `avg`          | average              |
| `sum`          | total sum            |
| `first`, `last`| the first / last of elements |
| `min`, `max`   | min / max            |
| `rss`          | root sum square      |
| `rms`          | root mean square     |

These functions differ from the other functions above in that they hold all the values
of the corresponding period in memory buffer and generate the value when the time window changed.

| field                 | description          |
| :-------------------- | :------------------- |
| `mean`                | mean                 |
| `median`              | median (lower value) |
| `meidan-interpolated` | median (lower interpolated value) |
| `stddev`              | standard deviation   |
| `stderr`              | standard error       |
| `entropy`             | Shannon entropy of a distribution. The natural logarithm is used. |


```js
FAKE( oscillator(
        freq(10, 1.0), freq(35, 2.0), 
        range('now', '10s', '10ms')) 
)
TIMEWINDOW(
    time("now-2s"),
    time("now+13s"),
    period("1s"),
    "time",
    "rms"
)
CSV()
```

## WHEN()

*Syntax*: `WHEN(condition, doer)` {{< neo_since ver="8.0.7" />}}

- `condition` *boolean*
- `doer` *doer*

`WHEN` runs `doer` action if the given condition is `true`.
This function does not affects the flow of records, it just executes the defined *side effect* work.

Available doer actions.

|    do                                     |   description            |
| :---------------------------------------- | :----------------------- |
| `doLog(args...)`                          | prints out log message   |
| `doHttp(method, url, body, header...)`    | send http request        |

```js
FAKE( linspace(1, 2, 2))
WHEN( mod(value(0), 2) == 0, doLog(value(0), "is even."))
CSV()
```

```js
FAKE( linspace(1, 4, 4))
WHEN( mod(value(0), 2) == 0, doHttp("POST", "http://127.0.0.1:8888/hello", values()))
CSV()
```

## FFT()

![map_fft](../img/map_fft.jpg)

*Syntax*: `FFT()`

It assumes value of the incoming record is an array of *time,amplitude* tuples, then applies *Fast Fourier Transform* on the array and replaces the value with an array of *frequency,amplitude* tuples. The key remains same.

For example, if the incoming record was `{key: k, value[ [t1,a1],[t2,a2],...[tn,an] ]}`, it transforms the value to `{key:k, value[ [F1,A1], [F2,A2],...[Fm,Am] ]}`.

## SCRIPT()

*Syntax*: `SCRIPT({ ... script code... })`

Supporting script language.

1. **tengo**
 [tengo](https://github.com/d5/tengo) is a Golang like script.
 The additional package "context" package is available that is exposing the TQL specific functionalities
 based the default packages from tengo.

![map_script](../img/map_script.jpg)