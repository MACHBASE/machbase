---
title: MAP Functions
type: docs
weight: 31
---

*MAP* functions are the core of the transforming data.

## TAKE()

![map_take](../img/map_take.jpg)

*Syntax*: `TAKE( [offset,] n )`

Takes first *n* records and stop the stream.

- `offset` *number* optional, take records from the offset. (default 0 when omitted) {{< neo_since ver="8.0.6" />}}
- `n` *number* specify how may records to be taken.

{{< tabs items="TAKE(n),TAKE(offset n)">}}
{{< tab >}}
```js {linenos=table,hl_lines=["9"],linenostart=1}
FAKE( json({
    [ "TAG0", 1628694000000000000, 10],
    [ "TAG0", 1628780400000000000, 11],
    [ "TAG0", 1628866800000000000, 12],
    [ "TAG0", 1628953200000000000, 13],
    [ "TAG0", 1629039600000000000, 14],
    [ "TAG0", 1629126000000000000, 15]
}))
TAKE(2)
CSV()
```
```csv
TAG0,1628694000000000000,10
TAG0,1628780400000000000,11
```
{{< /tab >}}
{{< tab >}}
```js {linenos=table,hl_lines=["9"],linenostart=1}
FAKE( json({
    [ "TAG0", 1628694000000000000, 10],
    [ "TAG0", 1628780400000000000, 11],
    [ "TAG0", 1628866800000000000, 12],
    [ "TAG0", 1628953200000000000, 13],
    [ "TAG0", 1629039600000000000, 14],
    [ "TAG0", 1629126000000000000, 15]
}))
TAKE(3, 2)
CSV()
```
```csv
TAG0,1628953200000000000,13
TAG0,1629039600000000000,14
```
{{< /tab >}}
{{< /tabs >}}

## DROP()

![map_drop](../img/map_drop.jpg)

*Syntax*: `DROP( [offset,] n  )`

Ignore first *n* records, it simply drops the *n* records.

- `offset` *number* optional, drop records from the offset. (default 0 when omitted) {{< neo_since ver="8.0.6" />}}
- `n` *number* specify how may records to be dropped.

{{< tabs items="DROP(n),DROP(offset n)">}}
{{< tab >}}
```js {linenos=table,hl_lines=["9"],linenostart=1}
FAKE( json({
    [ "TAG0", 1628694000000000000, 10],
    [ "TAG0", 1628780400000000000, 11],
    [ "TAG0", 1628866800000000000, 12],
    [ "TAG0", 1628953200000000000, 13],
    [ "TAG0", 1629039600000000000, 14],
    [ "TAG0", 1629126000000000000, 15]
}))
DROP(3)
CSV()
```
```csv
TAG0,1628953200000000000,13
TAG0,1629039600000000000,14
TAG0,1629126000000000000,15
```
{{< /tab >}}
{{< tab >}}
```js {linenos=table,hl_lines=["9"],linenostart=1}
FAKE( json({
    [ "TAG0", 1628694000000000000, 10],
    [ "TAG0", 1628780400000000000, 11],
    [ "TAG0", 1628866800000000000, 12],
    [ "TAG0", 1628953200000000000, 13],
    [ "TAG0", 1629039600000000000, 14],
    [ "TAG0", 1629126000000000000, 15]
}))
DROP(2, 3)
CSV()
```
```csv
TAG0,1628694000000000000,10
TAG0,1628780400000000000,11
TAG0,1629126000000000000,15
```
{{< /tab >}}
{{< /tabs >}}

## MAPKEY()

![map_mapkey](../img/map_mapkey.jpg)

*Syntax*: `MAPKEY( newkey )`

Replace current key value with the given newkey.

```js {linenos=table,hl_lines=["9"],linenostart=1}
FAKE( json({
    [ "TAG0", 1628694000000000000, 10],
    [ "TAG0", 1628780400000000000, 11],
    [ "TAG0", 1628866800000000000, 12],
    [ "TAG0", 1628953200000000000, 13],
    [ "TAG0", 1629039600000000000, 14],
    [ "TAG0", 1629126000000000000, 15]
}))
MAPKEY(time("now"))
PUSHKEY("do-not-see")
CSV()
```
```csv
1701343504143299000,TAG0,1628694000000000000,10
1701343504143303000,TAG0,1628780400000000000,11
1701343504143308000,TAG0,1628866800000000000,12
1701343504143365000,TAG0,1628953200000000000,13
1701343504143379000,TAG0,1629039600000000000,14
1701343504143383000,TAG0,1629126000000000000,15
```

## PUSHKEY()

![map_pushkey](../img/map_pushkey.jpg)

*Syntax*: `PUSHKEY( newkey )`

Apply new key on each record. The orignal key is push into value tuple.

For example, if an original record was `{key: 'k1', value: [v1, v2]}` and applied `PUSHKEY(newkey)`, it produces the updated record as `{key: newkey, values: [k1, v1, v1]}`.

```js {linenos=table,hl_lines=["10"],linenostart=1}
FAKE( json({
    [ "TAG0", 1628694000000000000, 10],
    [ "TAG0", 1628780400000000000, 11],
    [ "TAG0", 1628866800000000000, 12],
    [ "TAG0", 1628953200000000000, 13],
    [ "TAG0", 1629039600000000000, 14],
    [ "TAG0", 1629126000000000000, 15]
}))
MAPKEY(time("now"))
PUSHKEY("do-not-see")
CSV()
```
```csv
1701343504143299000,TAG0,1628694000000000000,10
1701343504143303000,TAG0,1628780400000000000,11
1701343504143308000,TAG0,1628866800000000000,12
1701343504143365000,TAG0,1628953200000000000,13
1701343504143379000,TAG0,1629039600000000000,14
1701343504143383000,TAG0,1629126000000000000,15
```

## POPKEY()

![map_popkey](../img/map_popkey.jpg)

*Syntax*: `POPKEY( [idx] )`

Drop current key of the record, then promote *idx*th element of *tuple* as a new key.

For example, if an original record was `{key: k, value: [v1, v2, v3]}` and applied `POPKEY(1)`, it produces the updated record as `{key: v2, value:[v1, v3]}`.

if use `POPKEY()` without argument it is equivalent with `POPKEY(0)` which is promoting the first element of the value tuple as the key.

{{< tabs items="POPKEY(),POPKEY(idx)">}}
{{< tab >}}
```js {linenos=table,hl_lines=["9"],linenostart=1}
FAKE( json({
    [ "TAG0", 1628694000000000000, 10],
    [ "TAG0", 1628780400000000000, 11],
    [ "TAG0", 1628866800000000000, 12],
    [ "TAG0", 1628953200000000000, 13],
    [ "TAG0", 1629039600000000000, 14],
    [ "TAG0", 1629126000000000000, 15]
}))
POPKEY()
CSV()
```
```csv
1628694000000000000,10
1628780400000000000,11
1628866800000000000,12
1628953200000000000,13
1629039600000000000,14
1629126000000000000,15
```
{{< /tab >}}
{{< tab >}}
```js {linenos=table,hl_lines=["9"],linenostart=1}
FAKE( json({
    [ "TAG0", 1628694000000000000, 10],
    [ "TAG0", 1628780400000000000, 11],
    [ "TAG0", 1628866800000000000, 12],
    [ "TAG0", 1628953200000000000, 13],
    [ "TAG0", 1629039600000000000, 14],
    [ "TAG0", 1629126000000000000, 15]
}))
POPKEY(1)
CSV()
```
```csv
TAG0,10
TAG0,11
TAG0,12
TAG0,13
TAG0,14
TAG0,15
```
{{< /tab >}}
{{< /tabs >}}

## GROUPBYKEY()

![map_popkey](../img/map_groupbykey.jpg)

*Syntax*: `GROUPBYKEY( [lazy(boolean)] )`

- `lazy(boolean)` If it set `false` which is default *GROUPBYKEY()* yields new grouped record when the key of incoming record has changed from previous record. If it set `true`, *GROUPBYKEY()* waits the end of the input stream before yield any record. 

Takes multiple continuous records that have same key, then produces a new record which have value array contains all individual values.

For example, if an original records was `{key:k, value:[v1, v2]}`, `{key:k, value:{v3, v4}}`...`{key:k, value:{vx, vy}}`, it produces the new record as `{key:k, value:[[v1,v2],[v3,v4],...,[vx,vy]]}`.

The *GROUPBYKEY()* works comparing the key of current record to previous one, if it found the key has been changed, then produces new record. As result it can makes a group only if the continuous records have same key.

## FLATTEN()

![map_flatten](../img/map_flatten.jpg)

*Syntax*: `FLATTEN()`

It works the oposite way of *GROUPBYKEY()*. Take a record whose value is multi-dimension tuple, produces multiple records for each elements of the tuple reducing the dimension.

For example, if an original record was `{key:k, value:[[v1,v2],[v3,v4],...,[vx,vy]]}`, it produces the new multiple records as `{key:k, value:[v1, v2]}`, `{key:k, value:{v3, v4}}`...`{key:k, value:{vx, vy}}`.

## PUSHVALUE()

*Syntax*: `PUSHVALUE( idx, value [, name] )` {{< neo_since ver="8.0.5" />}}

- `idx` *int* Index where newValue insert at. (0 based)
- `value` *expression* New value
- `name` *string* column's name (default 'column')

Insert the given value into the current values.

## POPVALUE()

*Syntax*: `PUSHVALUE( idx [, idx2, idx3, ...] )` {{< neo_since ver="8.0.5" />}}

- `idx` *int* array of indexes that will removed from values

It removes elements that specified by `idx`es from value array.

## MAPVALUE()

![map_mapvalue](../img/map_mapvalue.jpg)

*Syntax*: `MAPVALUE( idx, newValue [, newName] )`

- `idx` *int*  Index of the value tuple. (0 based)
- `newValue` *expression* New value
- `newName` *string* change column's name with given string

Replace the value of the element at the given index. For examaple, `MAPVALUE(0, value(0)*10)` replaces a new value that is 10 times of the first element of value tuple.

If the `idx` is out of range, it works as `PUSHVALUE()` does. `MAPVALUE(-1, value(1)+'_suffix')` inserts a new string value that concatenates '_suffix' with the 2nd element of value.

An example usage of math functions with `MAPVALUE`.

{{< tabs items="MAPVALUE(),RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=["7"],linenostart=1}
FAKE(
    meshgrid(
        linspace(-1.0,1.0,200),
        linspace(-1.0, 1.0, 200)
    )
)
MAPVALUE(2, sin(10*(pow(value(0), 2) + pow(value(1),2 )))/10 )
CHART_LINE3D(
    lineWidth(4),
    gridSize(100, 30, 100),
    visualMap(-0.12, 0.12)
)
```
{{< /tab >}}
{{< tab >}}
![tql-math-example2](../img/tql-math-example2.jpg)
{{< /tab >}}
{{< /tabs >}}


## FILTER()

![map_filter](../img/map_filter.jpg)

*Syntax*: `FILTER( condition )`

Apply the condition statement on the incoming record, then it pass the record only if the *condition* is *true*.

For example, if an original record was `{key: k1, value[v1, v2]}` and apply `FILTER(count(V) > 2)`, it simply drop the record. If the codition was `FILTER(count(V) >= 2)`, it pass the record to the next function.

```js {linenos=table,hl_lines=["9"],linenostart=1}
FAKE( json({
    [ "TAG0", 1628694000000000000, 10],
    [ "TAG0", 1628780400000000000, 11],
    [ "TAG0", 1628866800000000000, 12],
    [ "TAG0", 1628953200000000000, 13],
    [ "TAG0", 1629039600000000000, 14],
    [ "TAG0", 1629126000000000000, 15]
}))
FILTER( value(2) < 12 )
CSV()
```
```csv
TAG0,1628694000000000000,10
TAG0,1628780400000000000,11
```

## TIMEWINDOW()

*Synatax*: `TIMEWINDOW( fromTime, untilTime, period, [nullValue], fields...)` {{< neo_since ver="8.0.5" />}}

Aggregate raw values between fromTime and untilTime into a periodic duration and fill zero value if any value exists for the period.

- `fromTime` *time* from (inclusive)
- `untilTime` *time* until (exclusive)
- `period` *duration* ex: `period('1s')`
- `nullValue` if a certain period has no actual values it yields the given *alternativeValue*.(default is *NULL*) ex: `nullValue(alternativeValue)`
- `fields` *string* specifies each field's aggration function and indicates which column is the time. It should be one of pre-defines keywords. 

| field          |  description         |
| :------------- | :------------------- |
| `time`         | indicator for timestamp column  |
| `avg`          | average              |
| `sum`          | total sum            |
| `first`, `last`| the first / last of elements |
| `min`, `max`   | min / max            |
| `rss`          | root sum square      |
| `rms`          | root mean square     |

These functions differ from the other functions above in that they hold all the values
of the corresponding period in memory buffer and generate the value when the time window changed.

| field                 | description          |
| :-------------------- | :------------------- |
| `mean`                | mean                 |
| `median`              | median (lower value) |
| `meidan-interpolated` | median (lower interpolated value) |
| `stddev`              | standard deviation   |
| `stderr`              | standard error       |
| `entropy`             | Shannon entropy of a distribution. The natural logarithm is used. |

{{< tabs items="TIMEWINDOW(),RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=["8-14"],linenostart=1}
FAKE(
    oscillator(
        freq(10, 1.0), freq(35, 2.0), 
        range('now', '10s', '10ms')
    )
)

TIMEWINDOW(
    time("now-2s"),
    time("now+13s"),
    period("1s"),
    "time",
    "rms"
)
CSV()
```
{{< /tab >}}
{{< tab >}}
```csv
1701344409000000000,NULL
1701344410000000000,NULL
1701344411000000000,1.5880459235686215
1701344412000000000,1.5811378750006444
1701344413000000000,1.5811367906343738
1701344414000000000,1.581139611962448
1701344415000000000,1.5811362560240105
1701344416000000000,1.5811366244210001
1701344417000000000,1.5811369143604415
1701344418000000000,1.5811386189552126
1701344419000000000,1.5811394614482
1701344420000000000,1.5811356945156385
1701344421000000000,1.486296234631919
1701344422000000000,NULL
1701344423000000000,NULL
```
{{< /tab >}}
{{< /tabs >}}

## FFT()

![map_fft](../img/map_fft.jpg)

*Syntax*: `FFT()`

It assumes value of the incoming record is an array of *time,amplitude* tuples, then applies *Fast Fourier Transform* on the array and replaces the value with an array of *frequency,amplitude* tuples. The key remains same.

For example, if the incoming record was `{key: k, value[ [t1,a1],[t2,a2],...[tn,an] ]}`, it transforms the value to `{key:k, value[ [F1,A1], [F2,A2],...[Fm,Am] ]}`.

{{< tabs items="FFT(),RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=["12"],linenostart=1}
FAKE(
    oscillator(
        freq(15, 1.0), freq(24, 1.5),
        range('now', '10s', '1ms')
    ) 
)

MAPKEY('sample')

GROUPBYKEY()

FFT()

CHART_LINE(
    xAxis(0, 'Hz'),
    yAxis(1, 'Amplitude'),
    dataZoom('slider', 0, 10) 
)
```
{{< /tab >}}
{{< tab >}}
![web-fft-tql-2d](/images/web-fft-tql-2d.png)
{{< /tab >}}
{{< /tabs >}}


## WHEN()

*Syntax*: `WHEN(condition, doer)` {{< neo_since ver="8.0.7" />}}

- `condition` *boolean*
- `doer` *doer*

`WHEN` runs `doer` action if the given condition is `true`.
This function does not affects the flow of records, it just executes the defined *side effect* work.

### doLog()

*Syntax*: `doLog(args...)` {{< neo_since ver="8.0.7" />}}

Prints out log message on the web console.

```js {linenos=table,hl_lines=["2"],linenostart=1}
FAKE( linspace(1, 2, 2))
WHEN( mod(value(0), 2) == 0, doLog(value(0), "is even."))
CSV()
```

### doHttp()

*Syntax*: `doHttp(method, url, body [, header...])` {{< neo_since ver="8.0.7" />}}

- `method` *string*
- `url` *string*
- `body` *string*
- `header` *string* optional

`doHttp` requests the http endpoints with given method, url, body and headers.

**Use cases**

- Notify an event to the specific HTTP endpoint.

```js {linenos=table,hl_lines=["4"],linenostart=1}
FAKE( linspace(1, 4, 4))
WHEN(
    mod(value(0), 2) == 0,
    doHttp("GET", strSprintf("http://127.0.0.1:8888/notify?value=%.0f", value(0)), nil)
)
CSV()

```

- Post the current record to the specific HTTP endpoint in CSV which is default format of `doHttp`.

```js {linenos=table,hl_lines=["4"],linenostart=1}
FAKE( linspace(1, 4, 4))
WHEN(
    mod(value(0), 2) == 0,
    doHttp("POST", "http://127.0.0.1:8888/notify", value())
)
CSV()
```

- Post the current record in a custom JSON format to the specific HTTP endpoint.

```js {linenos=table,hl_lines=["4-8"],linenostart=1}
FAKE( linspace(1, 4, 4))
WHEN(
    mod(value(0), 2) == 0,
    doHttp("POST", "http://127.0.0.1:8888/notify", 
        strSprintf(`{"message": "even", "value":%f}`, value(0)),
        "Content-Type: application/json",
        "X-Custom-Header: notification"
    )
)
CSV()
```

### do()

*Syntax*: `do(args..., { sub-flow-code })` {{< neo_since ver="8.0.7" />}}

`do` executes the given sub flow code with passing `args...` arguments.

It is important to keep in mind that `WHEN()` is only for executing a side effect job on a certain condition.
`WHEN-do` sub flow cannot affects to the main flow, which means it cannot use SINKs that produce result on output stream like `CSV`, `JSON`, and `CHART_*`. The output of a sub flow will be ignored silently, any writing attempts from a sink are ignored and showing warning messages.

Effective SINKs in a sub flow may be `INSERT` and `APPEND` which is not related with output stream, so that it can write the specific values on a different table from main TQL flow. Otherwise use `DISCARD()` sink, it silently discards any records in the sub flow without warning messages.

```js {linenos=table,hl_lines=["9-13"],linenostart=1}
FAKE( json({
    [ 1, "hello" ],
    [ 2, "你好" ],
    [ 3, "world" ],
    [ 4, "世界" ]
}))
WHEN(
    mod(value(0), 2) == 0,
    do( "Greetings:", value(0), value(1), {
        ARGS()
        WHEN( true, doLog( value(0), value(2) ) )
        DISCARD()
    })
)
CSV()
```

The log messages of the above code shows the two important points.

1. The main flow is bloked and waits until its sub flow finishes the job.
2. The sub flow is executed every time for a record that matches the condition.

```
2023-12-02 07:54:42.160 TRACE 0xc000bfa580 Task compiled FAKE() → WHEN() → CSV()
2023-12-02 07:54:42.160 TRACE 0xc000bfa840 Task compiled ARGS() → WHEN() → DISCARD()
2023-12-02 07:54:42.160 INFO  0xc000bfa840 Greetings: 你好
2023-12-02 07:54:42.160 DEBUG 0xc000bfa840 Task elapsed 254.583µs
2023-12-02 07:54:42.161 TRACE 0xc000bfa9a0 Task compiled ARGS() → WHEN() → DISCARD()
2023-12-02 07:54:42.161 INFO  0xc000bfa9a0 Greetings: 世界
2023-12-02 07:54:42.161 DEBUG 0xc000bfa9a0 Task elapsed 190.552µs
2023-12-02 07:54:42.161 DEBUG 0xc000bfa580 Task elapsed 1.102681ms
```

**Use cases**

When sub flow retrieves data from other than its arguments, it can access the arguments with `args([idx])` option function.

- Execute query with sub flow's arguments.

```js
// pseudo code
// ...
WHEN( condition,
    do(value(0), {
        SQL(`select time, value from table where name = ?`, args(0))
        // ... some map functions...
        INSERT(...)
    })
)
// ...
```

- Retrieve csv file from external web server

```js
// pseudo code
// ...
WHEN( condition,
    do(value(0), value(1), {
        CSV( file( strSprintf("https://exmaple.com/data_%s.csv?id=%s", args(0), escapeParam(args(1)) )))
        WHEN(true, doHttp("POST", "http://my_server", value()))
        DISCARD()
    })
)
// ...
```

## SCRIPT()

*Syntax*: `SCRIPT({ ... script code... })`

Supporting user defined script language.

See [SCRIPT](../script/) section for the details with examples.

**tengo**

[tengo](https://github.com/d5/tengo) is a Golang like script.
The additional package "context" package is available that is exposing the TQL specific functionalities
based the default packages from tengo.

TQL can execute user defined script within `SCRIPT()` by passing codes inside `{`, `}`.

{{< callout type="info" >}}
<b>IMPORTANT</b><br/>
If the script doesn't call `context.yield()` and `context.drop()` explicitly for a record,
it passes the record to the next function without any changes.
{{< /callout >}}


![map_script](../img/map_script.jpg)

A context in the code of `SCRIPT()` provides serveral methods.

| method                |  description|
|:--------------------- | :----------------------------------------------------------------|
| `ctx.key()`           | returns the key of the current record                        |
| `ctx.value(idx)`      | returns the value of `idx`th value of the current record <br/>or returns whole records in an array if `idx` is omitted.   |
| `ctx.drop()`          | discards the current record                                 |
| `ctx.yield(values...)`| produces a new record from the given values... arguments    |
| `ctx.yieldKey(key, values...)`| produces a new record from the given key and values...   |
| `ctx.param(name [, default])` | returns the value of the request parameter for the given name.<br/>If the param specified by `name` *string* does not exists,it returns `default` *string*.<br/> If `default` is not specified, it returns empty string`""`   |
| `ctx.bridge(name)`    | returns bridge instance of the given name                        |
| `ctx.println(args...)`| print log message to the web console                             |

### context package

#### context.yield()

Pass the incoming arguments to the next function.

{{< tabs items="CODE,RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=["3-4"],linenostart=1}
SCRIPT({
    ctx := import("context")
    ctx.yield(0, 1, 2, 3)
    ctx.yield(1, 2, 3, 4)
})
CSV()
```
{{< /tab >}}
{{< tab >}}
```csv
0,1,2,3
1,2,3,4
```
{{< /tab >}}
{{< /tabs >}}

#### context.key()

Returns the key of the current record.

{{< tabs items="CODE,RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=["5"],linenostart=1}
FAKE( linspace(1,2,2))
MAPKEY("hello")
SCRIPT({
    ctx := import("context")
    ctx.yield(ctx.key(), ctx.value(0))
})
CSV()
```
{{< /tab >}}
{{< tab >}}
```csv
hello,1
hello,2
```
{{< /tab >}}
{{< /tabs >}}

#### context.value()

Returns the whole value of the current records in array. If the index is given, it returns the element of the values.

For example, If the current record is `[0, true, "hello", "world"]`

- `context.value()` returns the whole values of the record `[0, true, "hello", "world"]`
- `context.value(0)` returns the first element of the record `0`
- `context.value(3)` returns the last element of the record `"world"`

{{< tabs items="CODE,RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=["4"],linenostart=1}
FAKE( linspace(1,2,2))
SCRIPT({
    ctx := import("context")
    ctx.yield(ctx.value(0), ctx.value(0)*10)
})
CSV()
```
{{< /tab >}}
{{< tab >}}
```csv
1,10
2,20
```
{{< /tab >}}
{{< /tabs >}}

### times package

#### times.time_format()

Convert timestamp to a string.

{{< tabs items="CODE,RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=["11"],linenostart=1}
STRING(param("format_time") ?? "808210800000000000")
SCRIPT({
    ctx := import("context")
    times := import("times")
    text := import("text")

    epoch_txt := ctx.value(0)
    epoch := text.parse_int(epoch_txt, 10, 64)
    epoch = epoch / 1000000000

    t_time := times.time_format(epoch, "Mon Jan 2 15:04:05 -0700 MST 2006")

    ctx.yield(epoch, t_time)
})
CSV()
```
{{< /tab >}}
{{< tab >}}
```csv
808210800,Sat Aug 12 16:00:00 +0900 KST 1995
```
{{< /tab >}}
{{< /tabs >}}


#### times.parse()

Convert a string to timestamp.

{{< tabs items="CODE,RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=["8"],linenostart=1}
STRING(param("timestamp") ?? "Sat Aug 12 00:00:00 -0700 MST 1995")
SCRIPT({
    ctx := import("context")
    times := import("times")
    text := import("text")

    time_format := ctx.value(0)
    epoch := times.parse("Mon Jan 2 15:04:05 -0700 MST 2006", time_format)

    ctx.yield(epoch, time_format)
})
CSV()
```
{{< /tab >}}
{{< tab >}}
```csv
808210800000000000,Sat Aug 12 00:00:00 -0700 MST 1995
```
{{< /tab >}}
{{< /tabs >}}

### json package

#### json.decode()

Parse JSON string.

{{< tabs items="CODE,RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=[15,17,"19-21"],linenostart=1}
STRING(payload() ?? {{
  "tag": "pump",
  "data": {
    "string": "Hello TQL?",
    "number": "123.456",
    "time": 1687405320,
    "boolean": true
  },
  "array": ["elements", 234.567, 345.678, false]
}})
SCRIPT({
  json := import("json")
  ctx := import("context")
  // parse value as json
  obj := json.decode(ctx.value(0))
  // conditional expression
  if obj.data.boolean {
    // yield multiple records
    ctx.yield(obj.tag+"_0", obj.data.time*1000000000, obj.data.number)
    ctx.yield(obj.tag+"_1", obj.data.time*1000000000, obj.array[1])
    ctx.yield(obj.tag+"_2", obj.data.time*1000000000, obj.array[2])    
  } else {
    // discard the current record
    ctx.drop()
  }
})
CSV()
```
{{< /tab >}}
{{< tab >}}
```csv
pump_0,1687405320000000000,123.456
pump_1,1687405320000000000,234.567
pump_2,1687405320000000000,345.678
```
{{< /tab >}}
{{< /tabs >}}

If the script ends with `APPEND(...)` or `INSERT(...)` instead of `CSV()` the final result records will be written into database.

### Example

Open a new *tql* editor on the web ui and copy the code below and run it.

In this example, `linspace(-4,4,100)` generates an array contains 100 elements which are ranged from -4.0 to 4.0 in every `8/100` step. `meshgrid()` takes two array and produce meshed new array. As result of FAKE() in the example produces an array of 10000 elements (100 x 100 meshed) contains array of two float point numbers.
`SCRIPT()` function takes a code block which enclosed by `{` and `}` and run it for each record.
It takes the current record via `context.value()` then yield transformed data via `context.yield()`.

{{< tabs items="CODE,RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=["5-8"],linenostart=1}
FAKE(meshgrid(linspace(-4,4,100), linspace(-4,4, 100)))
SCRIPT({
  math := import("math")
  // Define a custom function in the script
  calc := func(a, b) {
    return math.sin(math.pow(a, 2) + math.pow(b, 2)) /
           (math.pow(a, 2) + math.pow(b, 2))
  }
  // Receive values of the record from context
  ctx := import("context")
  values := ctx.value()
  x := values[0]
  y := values[1]
  z := calc(x, y)
  // Yield new value
  //  - yieldKey() build and passes new value with new key to the next step.
  //  - yeild() build and passes new value to the next step with the received key from previous step
  ctx.yield(x, y, z)
})
CHART_LINE3D(
  // chart size in HTML syntax
  size('500px', '500px'),
  // width, height, depth grids in percentage
  gridSize(100,50,100),
  lineWidth(5), visualMap(-0.1, 1),
  // rotation speed in degree per sec.
  autoRotate(20)
)
```
{{< /tab >}}
{{< tab >}}
![web-tql-script-wave](/images/web-tql-script-wave.gif)
{{< /tab >}}
{{< /tabs >}}

The SCRIPT code above is actually equivalent with the TQL `MAPVALUE(2, ...)` function below.
The math functions used in MAPVALUE became available {{< neo_since ver="8.0.6" />}}.

{{< tabs items="CODE,RESULT">}}
{{< tab >}}
```js {linenos=table,hl_lines=["2-4"],linenostart=1}
FAKE(meshgrid(linspace(-4,4,100), linspace(-4,4, 100)))
MAPVALUE(2,
    sin(pow(value(0), 2) + pow(value(1), 2)) / (pow(value(0), 2) + pow(value(1), 2))
)
CHART_LINE3D(
  // chart size in HTML syntax
  size('500px', '500px'),
  // width, height, depth grids in percentage
  gridSize(100,50,100),
  lineWidth(5), visualMap(-0.1, 1),
  // rotation speed in degree per sec.
  autoRotate(20)
)
```
{{< /tab >}}
{{< tab >}}
![web-tql-script-wave](/images/web-tql-script-wave.gif)
{{< /tab >}}
{{< /tabs >}}
